;
; Default configuration file for DEDISbench
;
; Note:	This file will be used if the user doesnt pass
;		a specific file. To pass a specific config file
;		as parameter to DEDISbench use -f<file>
;

[execution]
# Input File with duplicate distribution default:internal file called dist_personalfiles. 
# DEDISbench can simulate five real distributions (see documentation for more info). For choosing these distributions the `value` must be dist_archival, dist_personalfiles, dist_highperf, dist_ubuntuamd or dist_kernels respectively. 
#The input file details the amount of blocks with a certain number of duplicates and the format is: <number_duplicates> <number_blocks>
distfile=conf/dist_kernels

# Access pattern for I/O operations: 0-sequential | 1-uniform | 2-TPCC(default)
access_type=0

# Number of concurrent processes default:4. Each process has an independent file associated or a common device if -i flag is used
nprocs=1

# Size of the file of each process in MB. If rawdevice option is used, this parameter defines the size of the raw device. default:2048 MB
filesize=65536

# Size of blocks for I/O operations in Bytes. default: 4096
blocksize=4096

# Enable or disable the population of process files/device before running DEDISbench: 0-disabled, 1-enabled (with realistic content), 2-enabled (with DD).
# Only enabled by default (with value 1) for READ and MIXED tests).
populate=0

# I/O Operations synchronization (default:0): 0-without fsync and O_DIRECT, 1-O_DIRECT, 2-fsync, 3-both.
#sync=0

# Processes write/read from a raw device instead of having an independent file. If more than one process is defined, each process is assingned with an independent region of the raw device, dependent on the raw device size. By default, if this flag is not set each process writes to an individual file.
rawdevice=/dev/mapper/vdobdus

# Enable integrity checks for read requests. Values: 0-No integrity check is done, 1-static integrity check is done when the benchmark ends, 2-online integrity check is done for benchmark read requests, 3-both online and static verifications are done
# Files must be pre-populated with realistic content for read and mixed workloads to ensure that integrity checks are always correct.
integrity=1

# Seed for random generator default:current time. Usefull for repeating
seed=1000

# Inject failure at a specific time period, each failure operation must be in the format type_failure:failure_distribution:time_to_inject (minutes). Type of failures are 0 - fill 1 - fill and 2 - fill. Failure distribution: 0 - follow content generation distribution, 1 - inject in the block with more duplicates, 2 - inject in the block with less duplicates, 3 - inject in a block without duplicates.
#faulttimer=0:1:2,1:2:4				

# Inject failure at a specific number of operations, each failure operation must be in the format type_failurer:failure_distribution:number_operations. Type of failures are 0 - fill 1 - fill and 2 - fill. Failure distribution: 0 - follow content generation distribution, 1 - inject in the block with more duplicates, 2 - inject in the block with less duplicates, 3 - inject in a block without duplicates.
#faultops=0:0:100
#,1:1:200

faultsconfig=./conf/fault-confs/vdo_bit_flips_write_1GB_top.yaml

[results]

# I/O latency results are written to a log file to extract additional statistics. Each process writes these values in a file called result<processid> and each line, corresponds to a single I/O operations and presents: (latency of I/O operation in microseconds) (current time in seconds).
#logging=0

# Write to file path the output of DEDISbench. This feature also writes two additional files with the same name as given in 'out' and a snaplat and snapthr suffix that shows the throughput and latency average values for 30 seconds intervals. It also writes the necessary files to plot a graph of both throughput and latency, with gnuplot. 
general_results=out:0:0
#general_results=out:0:5
#general_results=out:5:5

# generate an output log with the distribution actually generated by the benchmark. This also generates the files needed to plot the distribution with gnuplot.
#dist_results=odist

# generate an output log with the access pattern generated by the benchmark. This also generates the files needed to plot the accesses to each block, throught time, with gnuplot.
#access_results=acessos

# choose the directory where DEDISbench writes data
#tempfilespath=/mnt/dedis/

# generate and output log with the faults statistics generated by the benchmark.
faults_results=faults_out

operation_per_offset=op_offset

dedup_per_block=dedup_block

[structural]

# option to delete (or not) temporary files created by DEDISbench: 0-do not delete, 1-delete (default: 1)
#cleantemp=1

# option to keep (or not) dbs from previous executions: 0-do not delete, 1-delete (default: 0)
#keep_dbs=0

